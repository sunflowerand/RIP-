# RIP-
源代码组织：
src 目录中存在的源文件

1)list.c 实现了一个通用链表，用于路由表实现

2)rip.c 实现了 RIPv1 的所有关键功能——包括 2 个主要模块
	a)input- 要求输入处理
	b) 输出 - 要求输出处理

3) rip_simulation.c 通过为 RIP_PORT 创建套接字并调用输入和输出例程来实现对 RIPv1 的模拟。定时器是通过回调作为输出例程生成的，以生成定期更新

4)mem.c实现定时器中使用的内存管理

5)timer.c 实现定时器例程

6)log.h 定义日志记录功能

7) 可执行文件有 2 个参数——邻居文件名和日志文件名

邻居文件格式-
xx.xx.xx.xx

由 $ 终止的邻居的 IP 地址

如何构建和运行：

在linux环境下 ./RIPV1 neighbour(.log文件)  log(用于记录路由的.log文件)





3）设计：

假设：
        a) 每个链接的成本为 1
                b)邻居文件中邻居的IP地址

                3.1) 数据结构：

                3.1.1) 路由表    
                路由表是一个链表，每个节点有一个路由条目。
                每个条目将具有以下类型
lnode：通用链表指针
目的地：目的地的IP地址
指标：到达目的地的成本
Nexthop：到达目的地的路径上的下一个路由器的 IP 地址
Routechanged：将在路由更新时设置
Timeout_tmr：存放超时定时器的定时器对象
Garbage_tmr：存放垃圾定时器的定时器对象


3.1.2) RIP 消息
RIP 消息将具有 rip_entries 的标头和可变编号

命令：请求或响应
版本：IP 版本 - IPv4 或 IPv6

结构 rip_entry {
                简短的 int addrfamily;
                短整数_零；
                struct in_addr 目的地；
                uint32_t _zero1；
                uint32_t _zero2；
                uint32_t 指标；
}

Addrfamily：目前仅支持 AF_INET
目的地：目的地的IP地址
指标：到达目的地的成本

3.1.3) 邻居文件

邻居的 IP 地址必须写在一个文件中。此文件名传递为
可执行文件的第一个参数。

文件格式：IP 地址以 $ 结尾
例子 ：
192.168.4.1

3.1.4) 邻居列表

当前节点的邻居将被放置在邻居列表中



3.2) 模块

3.2.1) 初始化：
该模块读取邻居文件并填充邻居链表。
它还向所有邻居发送请求消息。
它还向它的邻居发送一条带有它自己的 ip 的消息。这是需要的时候
一个节点关闭，然后出现。

3.2.2) 输入——
模块做输入​​处理。
从 RIP 端口接收数据并调用相应的处理函数

可以有两种类型的消息：- 请求和响应


该函数会取端口接收到的数据缓冲区，
发送者和接收到的数据的长度。
它将在路由表中创建和更新条目。定时器
每个路由条目将根据情况设置/重置。如有变动
到路由表，将调用 send_update 发送触发更新。


该函数将处理请求消息并调用 send_update 发送一个
更新消息给请求者。




3.3) 定时器说明：

当一个条目被更新或新添加到路由中时
表，一个间隔为 30 秒的计时器（timeout_tmr）
已启动。如果计时器超时，则该条目无效并且
另一个计时器启动 120 秒（garbage_tmr）。如果这个定时器也
超时，该条目被删除。
实现了两个定时器的回调函数。

3.4) 命令行说明：
CLI 目前提供了添加路由和显示路由表的选项。
CLI 在单独的线程中运行。

         1]添加路线：它会要求用户关注
                         目的地：
                         指标：
                         下一站：

        2]显示路由表
